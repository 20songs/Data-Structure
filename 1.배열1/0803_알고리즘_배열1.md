# 0803 알고리즘 

## 오티

[SWEA](https://swexpertacademy.com/main/main.do)

* 매일 12시

  > Daily 홈워크 - SEA 업로드

* 매주 화, 목

  > LEARN의 Intermediate 에 해당하는 과제 이메일 발송

* 테스트

  * IM: 배열 + 2중 for

    > 재귀나 dfs, bfs로 풀게 되면 시간 초과 가능성이 높음

  * A형: 완전 검색 + 가지 치기 [재귀]

    ​        혹은  시뮬레이션
  

## 알고리즘

>  유한한 단계를 통해 문제를 해결하기 위한 절차나 방법. 
>
> 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다
>
> > **어떠한 문제를 해결하기 위한 절차**

* **예시**: 1부터 100까지의 합: +1, +2, +3 ..., +100 = 5,050

### 알고리즘 표현 방법

1. **수도코드**

```python
def Calcsum(n):
    sum <- 0
    for i in range(1, n+1):
        sum <- sum + i;
    return sum;
```

2. **순서도**

![image-20200803095545064](C:\Users\Owner\AppData\Roaming\Typora\typora-user-images\image-20200803095545064.png)

| sum  | i    | i<=100 |
| ---- | ---- | ------ |
| 0    | 1    | Yes    |
| 1    | 2    | Yes    |
| ...  | ...  | Yes    |
| ...  | 100  | Yes    |
| 5050 | 101  | No     |

### 알고리즘의 성능은 무엇으로 측정하는가

* APS 과정의 목표 중의 하나는 보다 좋은 알고리즘을 이해하고 활용하는 것

* 무엇이 좋은 알고리즘인가?

  * 정확성: 틀리면 안됨
  * 작업량: 얼마나 적은 연산으로 원하는 결과를 얻는가
  * 메모리 사용량: 메모리 사용량
  * 단순성: 코드의 길이 및 복잡도
  * 최적성: 개선의 여지가 없는가

* 성능 분석

  * 1) +1 +2 +3 ... +100 = 5,050 

    > 100번의 연산 (덧셈 100번)

  * 2) 100 * (1+100) / 2 = 5,050

    > 3번의 연산 (덧셈 1번, 곱셈 1번, 나눗셈 1번)

* 시간 복잡도

  * 실행되는 명령문의 개수를 계산

  * ```python
    def CalcSum(n):
        sum <- ; # 1번
        for i in range(1, n+1): # 1번
            sum <- sum + i; # 1번
        return sum;
    ```

    `1 + n*2 = 2n+1`

  * ``` python
    def CalcSum(n):
        return n*(n+1)//2 #3번
    ```

    `3번의 연산`

* 시간 복잡도의 빅-O표기법

  * 가장 큰 영향력을 주는 n에 대한 항만을 표시

  * 계수(Coefficient)생략하여 표시

  * 예시

    ```python
    O (3n+2) = O(3n) #최고차항 = O(n) # 계수 제거
    
    O(2n^2 + 10n + 100) = O(n^2)
    O(4) = O(1)
    ```

  * 문제

    > n개의 데이터를 입력 받아 저장한 후 각 데이터에 1씩 증가시킨 후 각 데이터를 출력하는 알고리즘의 시간 복잡도는?
    >
    > > O(n)

  * 그래프

    ![image-20200803103510621](C:\Users\Owner\AppData\Roaming\Typora\typora-user-images\image-20200803103510621.png)

  * 실제 실행시간 비교

  ![image-20200803103549079](C:\Users\Owner\AppData\Roaming\Typora\typora-user-images\image-20200803103549079.png)

---

---

## 배열

### 배열이란 무엇인가

> 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
>
> > list를 배열로 사용하여 풀어야 함 (in python)

* 예시

```
#
Num0 = 0;
Num1 = 1;
Num2 = 2;
Num3 = 3;
Num4 = 4;
Num5 = 5;
#
Num = [0,1,2,3,4,5]
```



### 배열의 필요성

* 프로그램 내 여러 변수가 필요할 때, 일일이 다른 변수명을 이용하여 자료에 접근하는 것이 매우 비효율적
* 배열을 사용하면 하나의 선언을 통해 둘 이상의 변수 선언이 가능
* 단순히 다수의 변수 선언을 의미하는 것이 아니라, 다수의 변수로는 하기 힘든 작업을 배열을 활용하면 쉽게 할 수 있음



### 1차원 배열

* 1차원 배열의 선언

  * 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성

    * 이름 : 프로그램 배열 이름

    * 예시

      `Arr = list()` , `Arr=[]`

* 1차원 배열의 접근

  * `Arr[0] =10;` // `배열 Arr의 0번째 원소에 10을 저장하세요`
  * `Arr[idx] = 20;` //`배열Arr의 idx번째 원소에 20을 저장하세요`

* 구조

  | code  |             |
  | ----- | ----------- |
  | data  | 전역, 정적  |
  | heap  | 참조형 변수 |
  | stack | 지역 변수   |
  * 파이썬은 이름과 타입이 같지 않은 리스트를 만들 수 있음
  * 배열은 type, name이 같아야 함
    * 변수에 data의 위치를 참조, 포인터, 할당 시키는 것이 Stack
    * 실제 변수가 참조하는 값의 위치가 heap
    
    

### 배열 활용 예제: Gravity

>  상자들이 쌓여있는 방이 있다. 
>
>  방이 오른쪽으로 90도 회전하여 상자들이 중력의 영향을 받아 낙하한다고 할 때, 
>
>  낙차가 가장 큰 상자를 구하여 그 낙차를 리턴하는 프로그램을 작성하시오.
>
>  * 중력은 회전이 완료된 후 적용된다.
>  * 상자들은 모두 한쪽 벽면에 붙여진 상태로 쌓여 2차원의 형태를 이루며 벽에서 떨어져서 쌓인 상자는 없다.
>  * 방의 가로 길이는 항상 100이며, 세로 길이도 항상 100이다.
>  * 즉, 상자는 최소 0, 최대 100 높이로 쌓을 수 있다.

##### 그림설명

![image-20200803132443786](C:\Users\Owner\AppData\Roaming\Typora\typora-user-images\image-20200803132443786.png)

* 입력

data = [7, 4, 2, 0 , 0, 6, 0, 7, 0]

* 출력

7

```python
data = [7,4,2,0,0,6,0,7,0]
result = 0
maxHeight = 0

for i in range(len(data)):
    #9
    #i의 최대 낙차 값은 len(data) - (i+1) : 9-1 = 8
    #i이후의 모든 행을 검사한다.
    maxHeight = len(data)-(i+1)
    for j in range(i+1,len(data),1):
        if data[i] <= data[j]:
        # 아래 행이 i행보다 상자가 많을 때, 최대낙차값을 1 감소
            maxHeight -= 1
    if result < maxHeight:
        result = maxHeight
print(result)
```

```
7
```



## 정렬

> 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순:ascending), 혹은 그 반대의 순서대로(내림차순:descending) 재배열 하는 것

* 키
  * 자료를 정렬하는 기준이 되는 특정 값
  * 서류를 번호대로 정렬, 카드를 번호대로 정렬

* 대표적인 정렬 방식

  * 버블 정렬 O(n^2)
  * 카운팅 정렬 O(n+k)
  * 선택 정렬 O(n^2)
  * 퀵 정렬 O(n log n)
  * 삽입 정렬 O(n^2)
  * 병합 정렬 O(n log n)

  

### 버블 정렬(Bubble Sort)

> 인접한 두 개의 원소를 비교하여 자리를 계속 교환하는 방식

* 정렬 과정

  * 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다

  * 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다

  * 교환하며 자리를 이동하는 모습이 물 위로 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 한다.

  * | 10    | 10    | 10    | 1      |
    | ----- | ----- | ----- | ------ |
    | **4** | **4** | **1** | **10** |
    | **8** | **1** | **4** | **4**  |
    | **1** | **8** | **8** | **8**  |

* 시간 복잡도

  * O(n^2)

* [55,7,78,12,42]를 버블 정렬하는 과정

  ```python
  1pass
  1) 55 | 7 | 78 | 12 | 42
  2) 7 | 55 | 78 | 12 | 42
  3) 7 | 55 | 78 | 12 | 42
  4) 7 | 55 | 12 | 78 | 42
  5) 7 | 55 | 12 | 42 | #78
  ```

  ```python
  2pass
  1) 7 | 55 | 12 | 42 | #78
  2) 7 | 55 | 12 | 42 | #78
  3) 7 | 12 | 55 | 42 | #78
  4) 7 | 12 | 42 | #55 | #78
  ```

  ```python
  3pass
  1) 7 | 12 | 42 | #55 | #78
  2) 7 | 12 | 42 | #55 | #78
  3) 7 | 12 | #42 | #55 | #78
  ```

  ```python
  4pass
  1) 7 | 12 | #42 | #55 | #78
  2) 7 | #12 | #42 | #55 | #78
  ```

  * n=5
    pass = 4
    Compare(pass 당 비교 횟수) = 4, 3, 2, 1

  ```python
  def BubbleSort(a): # 정렬할 List = range(4,0,-1), len(a)=5
      for i in range(len(a)-1,0,-1) : # 범위의 끝 위치
          for j in range(0,1):
              if a[j] > a[j+1]:
                  a[j], a[j+1] = a[j+1], a[j] # swap
  ```

  > 일반적으로 swap을 위해서는 제 3의 변수가 필요하다

  

### 카운팅 정렬

> 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

* 제한 사항

> **정수나 정수로 표현할 수 있는 자료('문자' > ASCII)**에 대해서만 적용 가능
>
> > 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다
> >
> > 문자열, 실수 등은 조작이 필요함
>
> 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.
>
> > indexing 규칙에 의거하여 최대값 +1의 배열을 생성해줘야 한다

* 시간 복잡도

  * **O (n+k): n은 리스크 길이, k는 정수 최대값**
  * 너무 큰 정수 n의 경우 적용이 어려울 수 있다

* **정렬과정**

  * [0,4,1,3,1,2,4,1]

  ```
  1단계
  Data에서 각 항목들의 발생 회수를 세고,
  정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장한다.
  
  DATA [0 | 4 | 1 | 3 | 1 | 2 | 4 | 1]
  COUNTS [0 | 0 | 0| 0 | 0] # 0 초기화
  >
  COUNTS [1 | 3 | 1 | 1 | 2]
  # counts[i]의 발생 회수를 기록
  ```

  ```
  2단계
  정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다 [누적시킨다]
  
  DATA [0 | 4 | 1 | 3 | 1 | 2 | 4 | 1]
  COUNTS [1 | 3 | 1 | 1 | 2]
  >
  COUNTS [1 | 4 | 5 | 6 | 8]
  # 1번째 앞까지 0 [0]
  # 4번째 앞까지 1 [0 1 1 1]
  # 5번째 앞까지 2 [0 1 1 1 2]
  # 6번째 앞까지 3 [0 1 1 1 2 3]
  # 8번째 앞까지 4 [0 1 1 1 2 3 4 4]
  ```

  ```python
  3단계
  
  counts[1]을 감소시키고 Temp에 1을 삽입한다.
  
  DATA [0 | 4 | 1 | 3 | 1 | 2 | 4 | #1]
  COUNTS [1 | 4 | 5 | 6 | 8]
  COUNTS [1 | #3 | 5 | 6 | 8]
  TEMP [  |  |  | 1 |  |  |  |  |]
  
  counts[4]를 감소시키고 Temp에 4를 삽입한다.
  
  DATA [0 | 4 | 1 | 3 | 1 | 2 | #4 | #1]
  COUNTS [1 | #3 | 5 | 6 | 8]
  COUNTS [1 | #3 | 5 | 6 | #7]
  TEMP [  |  |  | 1 |  |  |  | 4 |  ]
  
  counts[2]를 감소시키고 Temp에 2를 삽입한다.
  
  DATA [0 | 4 | 1 | 3 | 1 | #2 | #4 | #1]
  COUNTS [1 | #3 | 5 | 6 | #7]
  COUNTS [1 | #3 | #4 | 6 | #7]
  TEMP [  |  |  | 1 | 2 |  |  | 4 |  ]
  
  counts[1]을 감소시키고 Temp에 1를 삽입한다.
  
  DATA [0 | 4 | 1 | 3 | #1 | #2 | #4 | #1]
  COUNTS [1 | #3 | #4 | 6 | #7]
  COUNTS [1 | #2 | #4 | 6 | #7]
  TEMP [  |  | 1 | 1 | 2 |  |  | 4 |  ]
  
  counts[3]을 감소시키고 Temp에 3를 삽입한다.
  
  DATA [0 | 4 | 1 | #3 | #1 | #2 | #4 | #1]
  COUNTS [1 | #2 | #4 | 6 | #7]
  COUNTS [1 | #2 | #4 | #5 | #7]
  TEMP [  |  | 1 | 1 | 2 | 3 |  | 4 |  ]
  
  counts[1]을 감소시키고 Temp에 1를 삽입한다.
  
  DATA [0 | 4 | #1 | #3 | #1 | #2 | #4 | #1]
  COUNTS [1 | #2 | #4 | #5 | #7]
  COUNTS [1 | #1 | #4 | #5 | #7]
  TEMP [  | 1 | 1 | 1 | 2 | 3 |  | 4 |  ]
  
  counts[4]을 감소시키고 Temp에 4를 삽입한다.
  
  DATA [0 | 4 | 1 | 3 | 1 | #2 | #4 | #1]
  COUNTS [1 | #1 | #4 | #5 | #7]
  COUNTS [1 | #1 | #4 | #5 | #6]
  TEMP [  | 1 | 1 | 1 | 2 | 3 | 4 | 4 |  ]
  
  counts[0]]을 감소시키고 Temp에 0을 삽입한다.
  
  DATA [0 | 4 | 1 | 3 | 1 | #2 | #4 | #1]
  COUNTS [1 | #1 | #4 | #5 | #6]
  COUNTS [#0 | #1 | #4 | #5 | #7]
  TEMP [ 0 | 1 | 1 | 1 | 2 | 3 | 4 | 4 |  ]
  ```

* 수도코드

```python
def Counting_Sort(A, B, k) # k 는 최대값+1
# A [] -- 입력 배열(1 to k) :: Source
# B [] -- 정렬된 배열        :: Temp > 결과
# C [] -- 카운트 배열       :: 

C = [0] * k

for i in range (0,len(B)): # 카운팅
    C[A[i]] += 1

for i in range (1, len(C)): # 누적 = 할당될 값의 인덱스를 업데이트
    C[i] += C[i-1]
    
for i in range (len(B)-1,-1,-1): #대입
    B[C[A[i]]-1] = A[i]
    C[A[i]] -= 1
```

* 코드

```python
def Counting_Sort(A, B, k): # k 는 최대값+1

# A [] -- 입력 배열(1 to k) :: Source
# B [] -- 정렬된 배열        :: Temp > 결과
# C [] -- 카운트 배열       ::

    C = [0] * k

    for i in range(0, len(B)):  # 카운팅
        C[A[i]] += 1

    for i in range(1, len(C)):  # 누적 = 할당될 값의 인덱스를 업데이트
        C[i] += C[i - 1]

    for i in range(len(B)-1, -1, -1):  # 소트
        B[C[A[i]] - 1] = A[i]
        C[A[i]] -= 1

    return B

a = [0, 4, 1, 3, 1, 2, 4, 1] # 소스
b = [0] * len(a)             # 결과 저장 배열

print(a)
print(b)
print(Counting_Sort(a,b,max(a)+1))
```



## 완전 검색

### Baby-gin Game 

> 0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 run이라 하고, 3장의 카드가 동일한 번호를 갖는 경우를 triplet이라고 한다.
>
> > 6장의 카드가 run과 triplet으로만 구성된 경우를 baby-gin으로 한다
>
> > 6자리 숫자를 입력 받아 baby-gin 여부를 판단하는 프로그램을 작성하라

* **완전 검색**

  > 완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
  >
  > > Brute-force 혹은 generate-and-test기법 (컴퓨터의 힘 빌리기)

  * 모든 경우의 수를 테스트 하여 결과를 도출

  * 일반적으로 n이 작을 때 쓸 수 있음

  * 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작음

    * 문제를 풀 때, 가장 먼저 완전 검색 후 해답 도출하고

    * 성능 개선을 위해 다른 알고리즘을 사용하는 것이 바람직 함

      >  **다른 알고리즘: 완전검색(재귀)[DFS] + 가지치기(pruning)**
      >
      > > 주로 순열, 조합, 부분 집합 등을 재귀를 이용하여 구함

* 풀이
  * 고려할 수 있는 모든 경우의 수를 나열
    * [2,3,5,7,7,7] -> 6! = 720개의 경우의 수를 생성
  * 해답 테스트
    * 720가지의 경우의 수에 대해 run, triplet 테스트를 거쳐서 결과 도출



### 예시: 순열

> 서로 다른 것들 중 몇 개를 뽑아 한 줄로 나열하는 것 [순서]
>
> 서로 다른 n 개 중 r 개를 택하면
>
> > nPr
>
> nPr = n * (n-1) \* (n-2) \* ... \*(n-r+1)
>
> > nPn = n!

* 예시 {1,2,3}을 포함하는 모든 순열

  * 동일한 숫자가 포함되지 않았을 때, 각 자리수 별로 loop를 이용해 아래와 같이 구현

  ```python
  # 순열, 비복원 추출
  for i1 in range(1,4):
      for i2 in range(1,4):
          if i2 != i1:
              for i3 in range(1,4):
                  if i3 != i1 and i3 != i2:
                      print(i1,i2,i3)
  ```

  ```python
  # 중복 순열, 복원 추출
  for i1 in range(1,4):
      for i2 in range(1,4):
          for i3 in range(1,4):
              print(i1,i2,i3)
  ```

  * **만약, 예시의 원소가 n개라면 n 중첩 for 문을 작성해야 함**



## 탐욕 알고리즘

> 탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적 방법
>
> 여러 경우 중 **하나를 결정해야 할 때마다** 그 **순간에 최적이라고 생각되는 것을 선택**해 나가는 방식으로 진행하여 **최종적인 해답**에 도달
>
> 각 선택의 시점에서 이루어지는 결정은 지역적으로 최적이지만, 그 선택들을 계속 수집하여 최종적 해답을 만들었다고 하여, 그것이 **최적이라는 보장은 없다**
>
> 일반적으로 머릿속에 떠오른 생각을 검증 없이 구현하면 Greedy 접근이다

* 동작 과정

  * 해 선택

    > **현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합에 추가**

  * 실행 가능성 검사

    > 새로운 부분해 집합이 **실행 가능한지를 확인**한다.
    >
    > 곧, 문제의 제약 조건을 위반하지 않았는지를 검사한다.

  * 해 검사

    > **새로운 부분해 집합이 문제의 해가 되는지를 확인한다.**
    >
    > 아직 전체 문제의 해가 완성되지 않았다면 해 선택부터 다시 시작한다.

* 거스름돈 예시

  * 해 선택

    > 현재 고를 수 있는 단위가 **가장 큰 동전**을 하나 골라 추가

  * 실행 가능성 검사

    > **액수를 초과하는지 확인**하여 **초과하면 빼고 아니면 1)로 돌아감**

  * 해 검사

    > 총액이 **거스름돈과 일치하는지 확인**하여 **아니라면 1)로 돌아감**



### Baby-gin with 탐욕 알고리즘(greedy)

> 6개의 숫자는 6자리 정수 값으로 입력
>
> counts 배열의 각 원소를 체크하여 run, triplet -> baby-gin 여부 판단

* Counts 사용

![image-20200803154007738](C:\Users\Owner\AppData\Roaming\Typora\typora-user-images\image-20200803154007738.png)

* 코드

```python
num = 456789  # Baby Gin 확인할 6자리 수

c = [0] * 12  # 6자리 수로부터 각 자리 수를 추출하여 개수를 누적할 리스트

for i in range(6):
    c[num % 10] += 1
    num //= 10

i = 0
tri = run = 0
while i < 10:
    if c[i] >= 3:  # triplete 조사 후 데이터 삭제
        c[i] -= 3
        tri += 1
        continue;  # i += 1을 하지 않기 위해서, 같은 게 6개 있을 수도 있음
    if c[i] >= 1 and c[i + 1] >= 1 and c[i + 2] >= 1:  # run 조사 후 데이터 삭제
        c[i] -= 1
        c[i + 1] -= 1
        c[i + 2] -= 1
        run += 1
        continue # run 의 경우의 수가 2개 발생할 수 있음
    i += 1

if run + tri == 2: 	#6//3 Baby-Gin 6개에서 발생 가능한 run, tri의 개수
    print("Baby Gin")
else:
    print("Lose")
```

* **주의할 오답: 정렬**

```python
correct case
[6, 4, 4, 5, 4, 4]
- [4, 4, 4, 4, 5, 6]

Wrong case
[1, 2, 3, 1, 2, 3]
- [1, 1, 2, 2, 3, 3]
```





